<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>行有不得，反求诸己</title>
    <link href="/2023/07/18/%E8%A1%8C%E6%9C%89%E4%B8%8D%E5%BE%97%EF%BC%8C%E5%8F%8D%E6%B1%82%E8%AF%B8%E5%B7%B1/"/>
    <url>/2023/07/18/%E8%A1%8C%E6%9C%89%E4%B8%8D%E5%BE%97%EF%BC%8C%E5%8F%8D%E6%B1%82%E8%AF%B8%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<p>本文以一种杂乱的意识流的形式记录，主要为方便记录自我意识以及探寻过程。组织架构可能不适合他人阅读，见谅。</p><p>本文以显式意识流的形式展开：</p><ul><li>音乐数据挖掘</li><li>搭建感性与理性之间的桥梁</li><li>感性：入耳的声音</li><li>理性：数字音频</li><li>再具体一些</li><li>感性：能够播放的音频文件</li><li>理性：能够分析的数据</li><li>那么，我需要做的是了解如何把播放的音频文件转换为能够分析的数据，反之亦然。</li><li><code>librosa</code> 中的 <code>load()</code> 为高级的音频读取功能包，其代码详见（<a href="https://github.com/librosa/librosa/blob/main/librosa/core/audio.py），主要利用">https://github.com/librosa/librosa/blob/main/librosa/core/audio.py），主要利用</a> <code>audioread</code> 和 <code>soundfile</code> 两个功能包。其能够将音频文件转换为时间序列数据。</li><li>这个时间序列数据代表什么？</li><li>通过源码进行分析：</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">y, sr_native = __audioread_load(path, offset, duration, dtype)<br>y, sr_native = __soundfile_load(path, offset, duration, dtype)<br><br></code></pre></td></tr></table></figure> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">__soundfile_load</span>(<span class="hljs-params">path, offset, duration, dtype</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;Load an audio buffer using soundfile.&quot;&quot;&quot;</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(path, sf.SoundFile):<br>        <span class="hljs-comment"># If the user passed an existing soundfile object,</span><br>        <span class="hljs-comment"># we can use it directly</span><br>        context = path<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-comment"># Otherwise, create the soundfile object</span><br>        context = sf.SoundFile(path)<br><br>    <span class="hljs-keyword">with</span> context <span class="hljs-keyword">as</span> sf_desc:<br>        sr_native = sf_desc.samplerate<br>        <span class="hljs-keyword">if</span> offset:<br>            <span class="hljs-comment"># Seek to the start of the target read</span><br>            sf_desc.seek(<span class="hljs-built_in">int</span>(offset * sr_native))<br>        <span class="hljs-keyword">if</span> duration <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            frame_duration = <span class="hljs-built_in">int</span>(duration * sr_native)<br>        <span class="hljs-keyword">else</span>:<br>            frame_duration = -<span class="hljs-number">1</span><br><br>        <span class="hljs-comment"># Load the target number of frames, and transpose to match librosa form</span><br>        y = sf_desc.read(frames=frame_duration, dtype=dtype, always_2d=<span class="hljs-literal">False</span>).T<br><br>    <span class="hljs-keyword">return</span> y, sr_native<br></code></pre></td></tr></table></figure><p>重点关注 <code>sf_desc</code> 变量：</p><ol><li><p>函数首先检查 <code>path</code> 是否是 <code>sf.SoundFile</code> 的实例，如果是，则直接使用它，否则创建一个新的 <code>sf.SoundFile</code> 对象。</p></li><li><p>使用 <code>with</code> 语句打开 <code>context</code>，并将其赋值给 <code>sf_desc</code>。然后，从 <code>sf_desc</code> 中获取采样率 <code>sr_native</code>。如果 <code>offset</code> 的值非零，则将 <code>sf_desc</code> 定位到目标读取的起始位置。接下来，根据传入的 <code>duration</code> 计算要读取的帧数 <code>frame_duration</code>，如果 <code>duration</code> 是 <code>None</code>，则将 <code>frame_duration</code> 设置为 -1，表示读取到文件末尾。</p></li></ol><p>我们可以认为 <code>sf_desc</code> 是一个 <code>sf.SoundFile</code> 类的实例。那么我们需要详细了解该类的方法和属性：</p><p><code>sf.SoundFile</code> 对象提供了一系列的方法和属性，用于操作音频文件。下面是其中一些常用的方法和属性：</p><ul><li><code>read(frames, dtype, always_2d)</code>: 从音频文件中读取指定数量的帧。它返回一个二维的 NumPy 数组，其中每行代表一个声道的音频数据。<code>frames</code> 参数指定要读取的帧数，<code>dtype</code> 参数指定返回的数据类型，<code>always_2d</code> 参数指定是否将结果始终作为二维数组返回。</li><li><code>seek(frame)</code>: 将文件指针移动到指定的帧位置。</li><li><code>samplerate</code>: 音频文件的采样率。</li><li><code>channels</code>: 音频文件的声道数。</li><li><code>duration</code>: 音频文件的持续时间（以秒为单位）。</li><li><code>close()</code>: 关闭音频文件。</li></ul><p>其中，从音频文件中读取指定数量的帧是音频处理中的常见操作，帧（frames）是音频信号的离散时间片段，每一帧包含一定数量的音频样本。读取音频文件的帧可以让我们获取音频数据的特定部分，以便进行后续的处理或分析。在音频文件中，音频信号是由一系列连续的采样点组成的。每个采样点表示在特定时间点上的音频振幅值。在读取过程中，每个帧会被转换为一组采样点的值，并以一维或二维数组的形式返回。数组的维度取决于音频的声道数和 <code>always_2d</code> 参数的设置。我们详细参见 <code>soundfile</code>中的<code>read</code> 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, frames=-<span class="hljs-number">1</span>, dtype=<span class="hljs-string">&#x27;float64&#x27;</span>, always_2d=<span class="hljs-literal">False</span>,</span><br><span class="hljs-params">             fill_value=<span class="hljs-literal">None</span>, out=<span class="hljs-literal">None</span></span>):<br>  <span class="hljs-keyword">if</span> out <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            frames = self._check_frames(frames, fill_value)<br>            out = self._create_empty_array(frames, always_2d, dtype)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> frames &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> frames &gt; <span class="hljs-built_in">len</span>(out):<br>                frames = <span class="hljs-built_in">len</span>(out)<br>        frames = self._array_io(<span class="hljs-string">&#x27;read&#x27;</span>, out, frames)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(out) &gt; frames:<br>            <span class="hljs-keyword">if</span> fill_value <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                out = out[:frames]<br>            <span class="hljs-keyword">else</span>:<br>                out[frames:] = fill_value<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><p>其关键在于：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">frames = self._array_io(<span class="hljs-string">&#x27;read&#x27;</span>, out, frames)<br></code></pre></td></tr></table></figure><p>继续刨根问底：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_array_io</span>(<span class="hljs-params">self, action, array, frames</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Check array and call low-level IO function.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> (array.ndim <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-keyword">or</span><br>                array.ndim == <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> self.channels != <span class="hljs-number">1</span> <span class="hljs-keyword">or</span><br>                array.ndim == <span class="hljs-number">2</span> <span class="hljs-keyword">and</span> array.shape[<span class="hljs-number">1</span>] != self.channels):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Invalid shape: &#123;0!r&#125;&quot;</span>.<span class="hljs-built_in">format</span>(array.shape))<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> array.flags.c_contiguous:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Data must be C-contiguous&quot;</span>)<br>        ctype = self._check_dtype(array.dtype.name)<br>        <span class="hljs-keyword">assert</span> array.dtype.itemsize == _ffi.sizeof(ctype)<br>        cdata = _ffi.cast(ctype + <span class="hljs-string">&#x27;*&#x27;</span>, array.__array_interface__[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> self._cdata_io(action, cdata, ctype, frames)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">_cdata_io</span>(<span class="hljs-params">self, action, data, ctype, frames</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;Call one of libsndfile&#x27;s read/write functions.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">assert</span> ctype <span class="hljs-keyword">in</span> _ffi_types.values()<br>        self._check_if_closed()<br>        <span class="hljs-keyword">if</span> self.seekable():<br>            curr = self.tell()<br>        func = <span class="hljs-built_in">getattr</span>(_snd, <span class="hljs-string">&#x27;sf_&#x27;</span> + action + <span class="hljs-string">&#x27;f_&#x27;</span> + ctype)<br>        frames = func(self._file, data, frames)<br>        _error_check(self._errorcode)<br>        <span class="hljs-keyword">if</span> self.seekable():<br>            self.seek(curr + frames, SEEK_SET)  <span class="hljs-comment"># Update read &amp; write position</span><br>        <span class="hljs-keyword">return</span> frames<br></code></pre></td></tr></table></figure><p>代码使用 <code>getattr</code> 函数根据操作类型 <code>action</code> 和数据类型 <code>ctype</code> 来获取相应的 <code>libsndfile</code> 库函数，并将其存储在 <code>func</code> 变量中。接着，使用 <code>func</code> 调用相应的读写函数，以执行实际的数据读取或写入操作。读取或写入的帧数存储在变量 <code>frames</code> 中。</p><p>我们追究到C代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span> ((readcount = (<span class="hljs-type">int</span>)sf_read_float(infile, buffer, BUFFER_LEN)) &gt; <span class="hljs-number">0</span>)<br>        sf_write_float(outfile, buffer, readcount);<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sf_count_t</span><span class="hljs-title function_">sf_read_float</span><span class="hljs-params">(SNDFILE *sndfile, <span class="hljs-type">float</span> *ptr, <span class="hljs-type">sf_count_t</span> items)</span> ;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">sf_count_t</span><br><span class="hljs-title function_">sf_read_float</span><span class="hljs-params">(SNDFILE *sndfile, <span class="hljs-type">float</span> *ptr, <span class="hljs-type">sf_count_t</span> len)</span><br>&#123;SF_PRIVATE *psf ;<br><span class="hljs-type">sf_count_t</span>count, extra ;<br><br><span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br><br>VALIDATE_SNDFILE_AND_ASSIGN_PSF (sndfile, psf, <span class="hljs-number">1</span>) ;<br><br><span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>)<br>&#123;psf-&gt;error = SFE_NEGATIVE_RW_LEN ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125; ;<br><br><span class="hljs-keyword">if</span> (psf-&gt;file.mode == SFM_WRITE)<br>&#123;psf-&gt;error = SFE_NOT_READMODE ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125; ;<br><br><span class="hljs-keyword">if</span> (len % psf-&gt;sf.channels)<br>&#123;psf-&gt;error = SFE_BAD_READ_ALIGN ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125; ;<br><br><span class="hljs-keyword">if</span> (psf-&gt;read_current &gt;= psf-&gt;sf.frames)<br>&#123;psf_memset (ptr, <span class="hljs-number">0</span>, len * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">float</span>)) ;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br>&#125; ;<br><br><span class="hljs-keyword">if</span> (psf-&gt;read_float == <span class="hljs-literal">NULL</span> || psf-&gt;seek == <span class="hljs-literal">NULL</span>)<br>&#123;psf-&gt;error = SFE_UNIMPLEMENTED ;<br><span class="hljs-keyword">return</span><span class="hljs-number">0</span> ;<br>&#125; ;<br><br><span class="hljs-keyword">if</span> (psf-&gt;last_op != SFM_READ)<br><span class="hljs-keyword">if</span> (psf-&gt;seek (psf, SFM_READ, psf-&gt;read_current) &lt; <span class="hljs-number">0</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span> ;<br><br>count = psf-&gt;read_float (psf, ptr, len) ;<br><br><span class="hljs-keyword">if</span> (psf-&gt;read_current + count / psf-&gt;sf.channels &lt;= psf-&gt;sf.frames)<br>psf-&gt;read_current += count / psf-&gt;sf.channels ;<br><span class="hljs-keyword">else</span><br>&#123;count = (psf-&gt;sf.frames - psf-&gt;read_current) * psf-&gt;sf.channels ;<br>extra = len - count ;<br>psf_memset (ptr + count, <span class="hljs-number">0</span>, extra * <span class="hljs-keyword">sizeof</span> (<span class="hljs-type">float</span>)) ;<br>psf-&gt;read_current = psf-&gt;sf.frames ;<br>&#125; ;<br><br>psf-&gt;last_op = SFM_READ ;<br><br><span class="hljs-keyword">return</span> count ;<br>&#125; <span class="hljs-comment">/* sf_read_float */</span><br><br></code></pre></td></tr></table></figure><p>其中最主要的部分为调用 <code>psf-&gt;read_float</code> 函数从音频文件中读取音频数据，并将其存储到提供的缓冲区 <code>ptr</code> 中，读取的数据项数存储在 <code>count</code> 中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">count = psf-&gt;read_float (psf, ptr, len) ;<br></code></pre></td></tr></table></figure><p>矛头直指 <code>psf</code> 对应的结构体 <code>SF_PRIVATE</code>，我以为我要触摸到真实的函数实现了，但是我在头文件中找到了以下注释：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*=======================================================================================</span><br><span class="hljs-comment">**SF_PRIVATE stuct - a pointer to this struct is passed back to the caller of the</span><br><span class="hljs-comment">**sf_open_XXXX functions. The caller however has no knowledge of the struct&#x27;s</span><br><span class="hljs-comment">**contents.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p><code>SF_PRIVATE</code> 结构体的定义和实现是在 libsndfile 库内部完成的，对于调用者来说是不可见的。</p><p>最后无功而返。这是一篇“无用”的文章。</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Music Data Mining 2(Audio Representation)</title>
    <link href="/2023/07/15/Music-Data-Mining-2-Audio-Representation/"/>
    <url>/2023/07/15/Music-Data-Mining-2-Audio-Representation/</url>
    
    <content type="html"><![CDATA[<h2 id="Audio-Representation"><a href="#Audio-Representation" class="headerlink" title="Audio Representation"></a>Audio Representation</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea"></a>Basic Idea</h3><p>To analyze music stored as a recorded audio signal we need to devise representations that roughly correspond to how we perceive sound through the auditory system. </p><p>At a fundamental level, such audio representations will help determine when things happen in time and how fast they repeat (frequency). Therefore, the foundation of any audio analysis algorithm is a representation that is structured around time and frequency.</p><p>In audio signal processing an important property of time and frequency transform is invertibility which means that the original audio signal or a very close approximation can be reconstructed from the values of the transform. </p><p>As the goal of audio feature extraction is analysis, typically a lot of information needs to be discarded and therefore perfect reconstruction is not as important.</p><h3 id="DFT"><a href="#DFT" class="headerlink" title="DFT"></a>DFT</h3><p>The <strong>DFT</strong> has its origins in the Fourier series in which any complicated continuous periodic function can be written as an infinite discrete sum of sine and cosine signals. Similarly, the <strong>DFT</strong> can be viewed as a similar process of representing any finite, discrete signal (properties required for processing by a computer) by a finite, discrete sum of discretized sine and cosine signals.</p><h3 id="STFT"><a href="#STFT" class="headerlink" title="STFT"></a>STFT</h3><p>The short-time Fourier transform (<strong>STFT</strong>) is arguably the most common time-frequency representation and has been widely used in many domains in addition to music processing. In addition, other audio feature representations such as the Mel-frequency cepstral coefficients (<strong>MFCCs</strong>) and chroma are based on the <strong>STFT</strong>. An important factor in the wide use of the <strong>STFT</strong> is the high speed with which it can be computed in certain cases when using the fast Fourier transform (<strong>FFT</strong>)  algorithm.</p><p>The fundamental idea behind the short-time Fourier transform (<strong>STFT</strong>) as well as many other time-frequency representations is to express a signal as a linear combination of basic elementary signals that can be more easily understood and manipulated. </p><p>It is possible to calculate the DFT of an entire audio clip and show how the energy of the signal is distributed among different frequencies. However, such an analysis would provide no information about when these frequencies start and stop in time. The idea behind the STFT is to process small segments of the audio clip at a time and the DFT of each segment. The output of the DFT is called a spectrum. The resulting sequence of spectrums (or spectra) contains information about time as well as frequency. The process of obtaining a small segment from a long audio signal can be viewed as a multiplication of the original audio signal with signal that has the value 1 during the time period of interest and the value 0 outside it. Such a signal is called a rectangular window.</p>]]></content>
    
    
    
    <tags>
      
      <tag>Shelter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Music Data Mining 1(Sound)</title>
    <link href="/2023/07/13/Music-Data-Mining-1-Sound/"/>
    <url>/2023/07/13/Music-Data-Mining-1-Sound/</url>
    
    <content type="html"><![CDATA[<h2 id="Sound"><a href="#Sound" class="headerlink" title="Sound"></a>Sound</h2><h3 id="Basic-Idea"><a href="#Basic-Idea" class="headerlink" title="Basic Idea:"></a>Basic Idea:</h3><ul><li>Definition</li></ul><p>Sound is created when air molecules are set into motion by some kind of vibration. The resulting changes in air pressure can be represented as a continuous signal over time. In order to represent the continuous process in a finite amount of memory the continuous signal is sampled at regular periodic intervals. The resulting sequence of samples which still has continuous values is then converted to a sequence of discretised samples through the process of quantization. </p><ul><li>Example</li></ul><p>CD quality audio has a sampling rate of 44,100 Hz and a dynamic range of 16 bit. This means each second of sound is represented as 44,100 samples equally spaced in time and each one of those samples is represented by 16 bits.</p><h3 id="Nyquist-Shannon-sampling-theorem"><a href="#Nyquist-Shannon-sampling-theorem" class="headerlink" title="Nyquist-Shannon sampling theorem"></a>Nyquist-Shannon sampling theorem</h3><p>If a function $x(t)$ contains no frequencies higher than $B$ Hertz, it can be completely reconstructed from a series of points spaced $\frac{1}{2B}$ seconds apart.</p><p>What this means is that if the highest frequency we are interested in is $B$ Hertz then we need to sample the signal at $2B$ Hertz or higher. As the data rates of audio signals are very high this has important implications.</p><ul><li>Example</li></ul><p>Telephone quality speech typically has a sampling rate of 16,000 Hz whereas CD audio has 44,100 Hz.</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] Howard, David M., and Jamie Angus. <em>Acoustics and psychoacoustics</em>. Taylor &amp; Francis, 2017.</p><p>[2] Li, Tao, Mitsunori Ogihara, and George Tzanetakis, eds. <em>Music data mining</em>. CRC Press, 2011.</p><p>[2] <a href="https://blog.csdn.net/Robin_Pi/article/details/109185986">https://blog.csdn.net/Robin_Pi/article/details/109185986</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Shelter</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传习录选</title>
    <link href="/2023/01/04/%E4%BC%A0%E4%B9%A0%E5%BD%95%E9%80%89/"/>
    <url>/2023/01/04/%E4%BC%A0%E4%B9%A0%E5%BD%95%E9%80%89/</url>
    
    <content type="html"><![CDATA[<ul><li>于事事物物上求至善，却是义外也。至善是心之本体，只是“明明德”在至精至一处便是，然亦未尝离却事物。本注所谓“尽夫天理之极，而无一毫人欲之私”者得之。</li><li>且如事父，不成去父上求个孝的理；事君，不成去君上求个忠的理；交友，治民，不成去友上、民上求个信和仁的理。都只在此心，心即理也。此心无私欲遮蔽，即是天理，不须外面添一分。以此纯乎天理之心，发之事父便是孝，发之事君便是忠，发之交友治民便是信和仁。只在此心去人欲、存天理上用功便是。</li><li>此心若无人欲、纯是天理，是个诚于孝亲的心，冬时自然思量父母的寒，便自要去求个温的道理。夏时自然思量父母的热，便自要去求个清的道理。这都是那诚孝的心发出来的条件。却是须有这诚孝的心，然后有这条件发出来。譬之树木，这诚孝的心便是根，许多条件便是枝叶。须先有根，然后有枝叶。不是先寻了枝叶，然后去种根。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>安身立命</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蓬室记</title>
    <link href="/2023/01/04/%E8%93%AC%E5%AE%A4%E8%AE%B0/"/>
    <url>/2023/01/04/%E8%93%AC%E5%AE%A4%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>既引杜甫《垂老别》以为名，便借以此诗，聊表对此博客的一点想法。</p><h3 id="四郊未宁静"><a href="#四郊未宁静" class="headerlink" title="四郊未宁静"></a>四郊未宁静</h3><p>长江东逝，思古伤怀：天灾，人祸，大则危及性命，小则累及得失。我总是白日放歌，晚上惴惴，于长夜沾湿之际入睡，于黄粱一梦之中醒来，骤地遇见日间繁重，叹一句：“难安……”。</p><h3 id="长揖别上官"><a href="#长揖别上官" class="headerlink" title="长揖别上官"></a>长揖别上官</h3><p>“男儿既介胄，长揖别上官”。面对复杂的命运，我无力的挣扎与这诗中老翁何异？可是，当我“投杖出门去”，甚至没有“同行为心酸”。世人同样挣扎，谁能有第二，第三颗心来为他人酸？</p><p>有的只是“老妻卧路啼，岁暮衣裳单”。亲近之人的苦难一览无余，我欲“伤其寒”之际又听闻其曰“劝加餐”。这些仅存的情谊被衬托地更加可怜与无助。</p><h3 id="土门壁甚坚"><a href="#土门壁甚坚" class="headerlink" title="土门壁甚坚"></a>土门壁甚坚</h3><p>土门壁有何坚，杏园又有何难度，无非是苦难在攻破我最后的堡垒。“人生有离合，岂择衰盛端。”命运拨弄我，我何能择命运？</p><h3 id="万国尽征戍"><a href="#万国尽征戍" class="headerlink" title="万国尽征戍"></a>万国尽征戍</h3><p>“万国尽征戍，烽火被冈峦。积尸草木腥，流血川原丹”人间无非如此，有的被粉饰罢了，故曰：“何乡为乐土？安敢尚盘桓。”</p><h3 id="弃绝蓬室居"><a href="#弃绝蓬室居" class="headerlink" title="弃绝蓬室居"></a>弃绝蓬室居</h3><p>蓬室或许是最后的乐土，愿此蓬室茅屋为我遮风挡雨，使我免受塌然催肺肝之苦！</p>]]></content>
    
    
    
    <tags>
      
      <tag>杂记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
